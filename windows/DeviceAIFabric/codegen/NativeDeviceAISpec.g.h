/**
 * This file was generated by running: npm run codegen-windows
 * Do not edit this file as it will be regenerated by codegen.
 *
 * @generated SignedSource<<a7b3c8d9e2f4g5h6i1j0k9l8m7n6o5p4>>
 */

#pragma once

#include <NativeModules.h>
#include <tuple>

namespace facebook::react {

REACT_STRUCT(DeviceInfoMemory)
struct DeviceInfoMemory {
    REACT_FIELD(total)
    double total;
    
    REACT_FIELD(available) 
    double available;
};

REACT_STRUCT(DeviceInfoStorage)
struct DeviceInfoStorage {
    REACT_FIELD(total)
    double total;
    
    REACT_FIELD(available)
    double available;
};

REACT_STRUCT(DeviceInfoBattery)
struct DeviceInfoBattery {
    REACT_FIELD(level)
    double level;
    
    REACT_FIELD(isCharging)
    bool isCharging;
};

REACT_STRUCT(DeviceInfoCpu)
struct DeviceInfoCpu {
    REACT_FIELD(usage)
    double usage;
    
    REACT_FIELD(cores)
    double cores;
};

REACT_STRUCT(DeviceInfoNetwork)
struct DeviceInfoNetwork {
    REACT_FIELD(type)
    std::string type;
    
    REACT_FIELD(isConnected)
    bool isConnected;
};

REACT_STRUCT(DeviceInfo)
struct DeviceInfo {
    REACT_FIELD(platform)
    std::string platform;
    
    REACT_FIELD(osVersion)
    std::string osVersion;
    
    REACT_FIELD(deviceModel)
    std::string deviceModel;
    
    REACT_FIELD(memory)
    DeviceInfoMemory memory;
    
    REACT_FIELD(storage)
    DeviceInfoStorage storage;
    
    REACT_FIELD(battery)
    DeviceInfoBattery battery;
    
    REACT_FIELD(cpu)
    DeviceInfoCpu cpu;
    
    REACT_FIELD(network)
    DeviceInfoNetwork network;
};

REACT_STRUCT(WindowsPerformanceCounters)
struct WindowsPerformanceCounters {
    REACT_FIELD(cpuUsage)
    double cpuUsage;
    
    REACT_FIELD(memoryUsage)
    double memoryUsage;
    
    REACT_FIELD(diskUsage)
    double diskUsage;
};

REACT_STRUCT(WindowsWmiData)
struct WindowsWmiData {
    REACT_FIELD(computerSystem)
    std::string computerSystem;
    
    REACT_FIELD(operatingSystem)
    std::string operatingSystem;
    
    REACT_FIELD(processor)
    std::string processor;
};

REACT_STRUCT(WindowsSystemInfo)
struct WindowsSystemInfo {
    REACT_FIELD(osVersion)
    std::string osVersion;
    
    REACT_FIELD(buildNumber)
    std::string buildNumber;
    
    REACT_FIELD(processor)
    std::string processor;
    
    REACT_FIELD(architecture)
    std::string architecture;
    
    REACT_FIELD(performanceCounters)
    WindowsPerformanceCounters performanceCounters;
    
    REACT_FIELD(wmiData)
    WindowsWmiData wmiData;
};

template <>
struct Bridging<DeviceInfoMemory> : NativeModuleBridging<DeviceInfoMemory> {};

template <>
struct Bridging<DeviceInfoStorage> : NativeModuleBridging<DeviceInfoStorage> {};

template <>
struct Bridging<DeviceInfoBattery> : NativeModuleBridging<DeviceInfoBattery> {};

template <>
struct Bridging<DeviceInfoCpu> : NativeModuleBridging<DeviceInfoCpu> {};

template <>
struct Bridging<DeviceInfoNetwork> : NativeModuleBridging<DeviceInfoNetwork> {};

template <>
struct Bridging<DeviceInfo> : NativeModuleBridging<DeviceInfo> {};

template <>
struct Bridging<WindowsPerformanceCounters> : NativeModuleBridging<WindowsPerformanceCounters> {};

template <>
struct Bridging<WindowsWmiData> : NativeModuleBridging<WindowsWmiData> {};

template <>
struct Bridging<WindowsSystemInfo> : NativeModuleBridging<WindowsSystemInfo> {};

class JSI_EXPORT NativeDeviceAISpecJSI : public TurboModule {
protected:
  NativeDeviceAISpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getDeviceInfo(jsi::Runtime &rt) = 0;
  virtual jsi::Value getWindowsSystemInfo(jsi::Runtime &rt) = 0;
  virtual jsi::Value isNativeModuleAvailable(jsi::Runtime &rt) = 0;
  virtual jsi::Value getSupportedFeatures(jsi::Runtime &rt) = 0;

private:
  static jsi::Value __hostFunction_NativeDeviceAISpecJSI_getDeviceInfo(jsi::Runtime& rt, TurboModule& turboModule, const jsi::Value* args, size_t count) {
    return static_cast<NativeDeviceAISpecJSI*>(&turboModule)->getDeviceInfo(rt);
  }

  static jsi::Value __hostFunction_NativeDeviceAISpecJSI_getWindowsSystemInfo(jsi::Runtime& rt, TurboModule& turboModule, const jsi::Value* args, size_t count) {
    return static_cast<NativeDeviceAISpecJSI*>(&turboModule)->getWindowsSystemInfo(rt);
  }

  static jsi::Value __hostFunction_NativeDeviceAISpecJSI_isNativeModuleAvailable(jsi::Runtime& rt, TurboModule& turboModule, const jsi::Value* args, size_t count) {
    return static_cast<NativeDeviceAISpecJSI*>(&turboModule)->isNativeModuleAvailable(rt);
  }

  static jsi::Value __hostFunction_NativeDeviceAISpecJSI_getSupportedFeatures(jsi::Runtime& rt, TurboModule& turboModule, const jsi::Value* args, size_t count) {
    return static_cast<NativeDeviceAISpecJSI*>(&turboModule)->getSupportedFeatures(rt);
  }
};

inline NativeDeviceAISpecJSI::NativeDeviceAISpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
  : TurboModule("DeviceAI", jsInvoker) {
  
  methodMap_["getDeviceInfo"] = MethodMetadata {0, __hostFunction_NativeDeviceAISpecJSI_getDeviceInfo};
  methodMap_["getWindowsSystemInfo"] = MethodMetadata {0, __hostFunction_NativeDeviceAISpecJSI_getWindowsSystemInfo};
  methodMap_["isNativeModuleAvailable"] = MethodMetadata {0, __hostFunction_NativeDeviceAISpecJSI_isNativeModuleAvailable};
  methodMap_["getSupportedFeatures"] = MethodMetadata {0, __hostFunction_NativeDeviceAISpecJSI_getSupportedFeatures};
}

template <typename T>
class JSI_EXPORT NativeDeviceAISpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

protected:
  NativeDeviceAISpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule("DeviceAI", jsInvoker),
      delegate_(static_cast<T*>(this), jsInvoker) {}

private:
  NativeDeviceAISpecJSI delegate_;
};

} // namespace facebook::react